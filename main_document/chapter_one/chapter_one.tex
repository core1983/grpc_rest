\chapter{Wstęp}
\section{Wprowadzenie}
W ostatnich latach w świecie IT można było zauważyć trend polegający na promowaniu budowania dużych systemów jako aplikacji rozproszonych składających się z wielu serwisów. Prelegenci na różnych konferencjach programistycznych przepowiadali schyłek wszelkich problemów podczas budowania wielkich systemów wykorzystywanych w biznesie. W dniu dzisiejszym rozwiązanie to określane jest architekturą opartą na \textbf{mikroserwisach}. Koncepcja ta nie jest czymś zupełnie nowym i możemy określić ją jako rozwinięcie architektury SOA (Service Oriented Architecture). Idea tworzenia oprogramowania w architekturze mikroserwisowej polega na budowaniu autonomicznych komponentów z których każdy odpowiada za konkretne zadanie. Elementy te współpracując ściśle ze sobą pozwalają na dostarczenie wymaganej logiki biznesowej w systemach rozproszonych. \par Wielu architektów oraz zespołów programistów wizja rozbicia swojej monolitycznej aplikacji na wiele mikroserwisów zachęciła do prób budowania takich rozwiązań. Pomimo początkowego entuzjazmu popartego niezaprzeczalnymi zaletami mikroserwisów takimi jak:
\begin{itemize}
	\item możliwości stosowania różnych technologii
	\item skalowalności
	\item odporności na awarie
\end{itemize}
dały o sobie znać wady, które spowodowały, że projektowanie, implementacja oraz utrzymanie takiej architektury stało się olbrzymim wyzwaniem dla firm produkujących oprogramowanie. Jednym z największych problemów okazał się sposób komunikacji pomiędzy mikroserwisami. Tym samym projektowanie interfejsów API \cite{jacobson2015interfejsapi} wymagało od architektów oraz programistów rozwiązania problemów w następujących kwestiach:
\begin{itemize}
	\item wyboru formatu wymiany danych (JSON, XML itp.)
	\item zaprojektowania punktów końcowych wywołania serwisów
	\item obsługi błędów 
	\item wydajności (ilość danych przy jednym wywołaniu serwisu, czas oczekiwania na odpowiedź)
	\item implementacji uwierzytelniania
	\item wybór technologii w której zostaną utworzone mikroserwisy
\end{itemize}
Mimo tych przeszkód korporacje pokroju Amazon, Netflix czy Google budują swoje olbrzymie systemy rozproszone w oparciu o mikroserwisy wykorzystując zróżnicowany stos technologii. Architektura mikroserwisowa przyczyniła się do spopularyzowania takich technologii jak chmura obliczeniowa (Amazon Web Services, Azure itp.) oraz rozwiązań opartych na kontenerach (Docker, Kubernetes).
\par Technologiczny potentat jakim jest niewątpliwe firma Google opierając swój biznes na usługach sieciowych stworzyła w tym celu technologię opartą na protokole RPC (Remote Procedure Call), która miałaby być panaceum na wyżej wymienione problemy w stosunku do \enquote{klasycznego} podejścia opartego na technologii REST\@.
\section{Cel i założenia pracy}
Celem niniejszej pracy jest zaprojektowanie oraz implementacja rozwiązania, które pozwoli rozbić prosty system monolityczny na grupę niezależnych usług sieciowych. Aplikacja zostanie zbudowana przy użyciu \textit{\enquote{klasycznego}} podejścia, gdzie wykorzystuje się komunikację opartą na technologii REST oraz przy udziale komunikacji opartej na zdalnym wywołaniu procedur(RPC). Logika każdego z serwisów zostanie oddzielona od warstwy transportu tak, aby w przyszłości było możliwie rozbudowanie systemu o dodatkowe funkcjonalności. Implementacja pozwoli opisać typowe problemy z jakimi spotykamy się podczas tworzenia architektury mikroserwisowej do których należą:
\begin{enumerate}
	\item Wykorzystanie różnych technologii do budowy poszczególnych komponentów systemu. Zakłada się wykorzystanie co najmniej dwóch języków programowania. Natura systemów rozproszonych sprawia, że nie są budowane przez jeden zespół programistów. Usługi, które stanowią część większego systemu realizują różne zadania. Nie istnieje jeden stos technologiczny, który byłby odpowiedni do każdego postawionego przed nim zadania więc należy używać odpowiednio dobranej technologii tam gdzie sprawdzi się najlepiej.
	\item Definiowanie punktów końcowych w komunikacji między usługami. Problemem w tym przypadku jest poprawne zdefiniowanie jakie dane oraz w jaki sposób będą przekazywane do poszczególnych usług. W przypadku podejścia wykorzystującego styl architektury REST są to dobrze skonstruowane adresy URI wraz z wersjonowaniem wersji API\@. W przypadku zdalnego wywołania procedur przejrzysta dokumentacją zdalnych metod wraz dokładny opis struktur przekazywanych w żądaniu oraz zwrotnych w odpowiedzi będzie istotnym wyzwaniem mającym znaczący wpływ na użyteczność mikroserwisów. 
	\item Zabezpieczenie danych przed nieuprawnionym przechwyceniem i odczytem. Informacje przekazywane pomiędzy usługami należy odpowiednio zabezpieczyć, nie może to być czysty tekst. W tym celu serwery HTTP oraz RPC będą implementować protokół SSL/TLS. Na potrzeby aplikacji działającej w obrębie jednej maszyny zostanie wygenerowany klucz prywatny podpisany przez własne główne centrum certyfikacji CS(ang. certificate authority). W rozwiązaniach, które będą funkcjonowały świecie rzeczywistym należy używać niezależnego oraz zaufanego centrum certyfikacji.
	\item Wydajność przesyłania oraz przetwarzania danych. W przypadku aplikacji monolitycznej przekazywanie danych pomiędzy poszczególnymi modułami odbywa się w pamięci lokalnej. W przypadku architektury mikroserwisowej dochodzi dodatkowa warstwa transportowa. Od formatu danych oraz użytego protokołu zależy ile czasu każda z usług będzie potrzebowała na przyjęcie informacji ewentualną serializację oraz przesłanie informacji zwrotnej. Pomiar wydajności zostanie zaimplementowany w kliencie i będzie obejmował wielokrotne wywołanie wybranych metod. Czas jaki upłynie od chwili przesłania żądania do momentu otrzymania informacji zwrotnej dla każdego udanego wywołania będzie sumowany dla kilku wybranych wartości powtórzeń w pętli. 
\end{enumerate}
\par Powyższe zagadnienia to nie jedyne problemy z jakimi muszą się zmierzyć projektanci mikroserwisów. Dochodzi do tego wiele aspektów związanych ze skalowaniem, obsługą błędów, monitorowaniem, ciągłej integracji źródeł kodu(Continuous Integration) itp. jednak są to zadania, którymi trzeba się zająć w dalszym etapie projektowania systemu i nie są bezpośrednio związane z metodami transportu danych.
